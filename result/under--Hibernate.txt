return ExecuteUpdateResultCheckStyle.COUNT;
String sequentialSelect = generateSequentialSelect(loadable);
return null;
return BatchingEntityLoaderBuilder.getBuilder( getFactory() )
None
for ( Object o : props.keySet() ) {
None
public Serializable[] getDisassembledState();
return true;
*           Environmental properties; currently unused.
return false;
None
None
if ( value instanceof ToOne ) {
return false;
id.setDynamic( !entity.hasPojoRepresentation() );
optimizer = Environment.getBytecodeProvider().getReflectionOptimizer( mappedClass, getterNames, setterNames, propTypes );
if ( component.getOwner().hasPojoRepresentation() ) {
return false;
mappings.addSecondPass( new ManyToOneSecondPass(manyToOne) );
aliasRefNode.resolve( false, false ); //TODO: is it kosher to do it here?
}
return false;
!( dialect instanceof MySQLDialect ) ||
}
LOG.debug( "Creating tables' unique integer identifiers" );
abstract static class CollectionType {
cascadeBeforeSave(source, persister, entity, createCache);
boolean indexIsFormula = false;
None
CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
java.util.Map propertyResults = bindPropertyResults(alias, returnElem, null, mappings );
None
// IMPL NOTE : currentDepth might be less-than zero if this is the
Property property = (Property) itr.next();
throw new QueryException( "duplicate association path: " + wholeAssociationPath );
}
* Right now HbmMetadataSourceProcessorImpl does not support the
None
too long.
None
too long.
None
}
return nullSafeGet(rs, names, session, owner);
copyCache.put( original, copy );
if ( "extra".equals( node.attributeValue("lazy") ) ) {
too long.
}
}
return new StringBuffer( ownerEntityTable ).append( "_" )
offset = writeKey( st, id, offset, session );
if ( !hasNotNullableColumns ) {
public static PropertyAccessor getPropertyAccessor(Class optionalClass, String type) throws MappingException {
public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {
private transient Class elementClass;
}
createForeignKeyOfEntity( ( (EntityType) getType() ).getAssociatedEntityName() );
return (Serializable[]) state;
None
too long.
) {
throw new DuplicateMappingException(
String [] idColNames = owner.getQueryable().getIdentifierColumnNames();
return StringHelper.unqualify(propertyName);
if ( null == mode || EntityMode.POJO.equals( mode ) ) {
int filteredParamCount = queryParameters.getFilteredPositionalParameterTypes() == null
None
private String substituteBrackets(String sqlQuery) throws QueryException {
private static final PropertyAccessor BASIC_PROPERTY_ACCESSOR = new BasicPropertyAccessor();
}
if ( oj.getJoinable().isCollection() ) {
LOG.trace( "Owning entity already loaded; ignoring" );
/*if ( isPrimaryKey && !isSpecialOneToOne ) {
None
too long.
public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {
}
registerFunction( "%exact", new StandardSQLFunction( "%exact", StandardBasicTypes.STRING ) );
too long.
return true;
( (initialVersion instanceof Number) && ( (Number) initialVersion ).longValue()<0 )
/*EntityPersister persister = getEntityPersister();
None
return false;
final Collection orphans;
rtn.hasNonReadOnlyEntities = ois.readBoolean();
/*if ( persister.hasCache() && !persister.isCacheInvalidationRequired() ) {
if (!persister.hasProxy()) {
None
public EntityLoadContext(LoadContexts loadContexts, ResultSet resultSet) {
if (LOG.isDebugEnabled()) {
if ( session.getFactory().getStatistics().isStatisticsEnabled() ) {
}
too long.
final String queryString = queryParameters.getFilteredSQL();
addExtraJoins( joinFragment, rootAlias, rootJoinable, true );
None
loadContexts.unregisterLoadingCollectionXRef( collectionKey );
too long.
too long.
PostLoadEvent postLoadEvent = new PostLoadEvent( session )
Object nextVersion = persister.forceVersionIncrement(
throw new HibernateException( "reassociated object has dirty collection reference (or an array)" );
too long.
removeCollection(persister, collectionKey, session);
return changed && existsInDatabase( target, source, persister );
public final class NameGenerator {
CollectionType type = (CollectionType) getDataType();
too long.
too long.
( ( DotNode ) dot ).setPropertyPath( ( ( FromReferenceNode ) property ).getPath() );
too long.
versionIncrementNode = getASTFactory().create( HqlSqlTokenTypes.PLUS, "+" );
None
too long.
private boolean compiled;
None
expr.setText( text );
too long.
None
too long.
too long.
too long.
switch ( x.getType() ) {
too long.
None
}
Node lhs = getLeftHandOperand();
return StandardBasicTypes.DOUBLE; //BLIND GUESS!
JoinSequence joinSequence = fromElement.getJoinSequence();
too long.
None
//session.getJDBCContext().getConnectionManager().closeQueryStatement( ps, resultSet );
too long.
String[] tokens = StringHelper.split( StringHelper.WHITESPACE + "(),", query, true );
too long.
Fo fo = Fo.newFo( (FumCompositeID) id );
public boolean isDereferencedBySuperclassProperty() {
None
Fo fo = Fo.newFo( (FumCompositeID) id );
oos.writeObject( loadedState );
/**
if ( manyToMany ) {
super( sql, flushMode, session, parameterMetadata );
// We would probably refactor to have LogicParser (builds a tree of simple
final Object result = persistenceContext.getEntity(key);
String replacement = ( String ) walker.getTokenReplacements().get( constant.getText() );
//We should actually rework this class to not implement Parser
return index==-1 ? 0 : getSubclassPropertyTableNumber(index);
return ( String[] ) subclassPropertyColumnNames.get( propertyName );
boolean[] includeOldField = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL
last();
return collectionName != null && !getPropertyType().isCollectionType();
private int dotcount;
NativeSQLQuerySpecification spec;
}
None
region.put( space, ts );
String[] tokens = StringHelper.split( ".", token, true );
None
@Override
too long.
int scalarSize = scalarTypes.size();
//The class is now way to complex!
None
return finalKey;
if ( discrimColumnName != null && !"clazz_".equals( discrimColumnName ) ) {
None
final PreLoadEvent preLoadEvent = new PreLoadEvent( session )
text = child.renderValueCollectionSelectFragment( nonscalarSize, nonscalarSize + k );
LOG.debug("could not log warnings", sqle);
final ComponentMetamodel metamodel = new ComponentMetamodel( this );
return Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
too long.
None
Criteria parent = null;
private final CriteriaQueryTranslator translator;
EntityUniqueKey euk = new EntityUniqueKey(
final String[][] cols = persister == rootPersister ?
CollectionElement elem = new CollectionElement();
HolderInstantiator holderInstantiator = buildHolderInstantiator( resultTransformer );
Type type = definition.getParameterType( name );
if ( element instanceof HibernateProxy ) {
}
//NOTE: unlike all other Loaders, this one is NOT
DecimalFormat jdkFormatter = new DecimalFormat( FORMAT_STRING );
else {
public Serializable disassemble(Object value, SessionImplementor session, Object owner)
ArrayList columnTableNumbers = new ArrayList();
}
/**
optimizer = Environment.getBytecodeProvider().getReflectionOptimizer(
private final EntityMetamodel entityMetamodel;
super.getReturnedClass().isInstance(parent);
EntityUniqueKey euk = new EntityUniqueKey(
ByteArrayOutputStream outputStream = new ByteArrayOutputStream(2048);
replaceElements( result, target, owner, copyCache, session );
return "";
*         FIXME: even if isInverse="true"?
Type keyType = getPersister( session ).getKeyType();
* Is the primary key of the owning entity table
None
int spacesSize = 1 + persistentClass.getSynchronizedTables().size();
AbstractQueryImpl query = (AbstractQueryImpl) session.getNamedSQLQuery(queryName);
Component component = (Component) prop.getValue();
throw new HibernateException( "illegally attempted to associate a proxy with two open Sessions" );
if ( inFromClause
None
pf.postInstantiate(
columnNames = getSessionFactoryHelper().generateColumnNames( queryReturnTypes );
}
None
too long.
SessionFactoryImplementor sessionFactory = getSessionFactoryHelper().getFactory();
too long.
}
None
String tableName = getTable().getQuotedName(dialect);
None
// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried
source.getPersistenceContext().addEntry(
copyCache.put( original, copy );
propertyName
too long.
EntityEntry entry = source.getPersistenceContext().getEntry(entity);
/*Object[] cachedState = null;
if ( object instanceof HibernateProxy ) {
cacheable,
LinkedHashSet<EntityKey> set =  batchLoadableEntityKeys.get( persister.getEntityName() );
OnReplicateVisitor visitor = new OnReplicateVisitor( source, id, entity, false );
return collection.wasInitialized() &&
too long.
too long.
Serializable entityId = getLoadedCollectionOwnerIdOrNull( ce );
}
//		registerColumnType(Types.VARBINARY,     "binary($1)");
}
None
None
SessionFactoryImplementor factory = session.getFactory();
None
oracleCursorTypeSqlType = extractOracleCursorTypeValue();
return "{?= call current_timestamp}";
if ( hsqldbVersion < 20 ) {
return getLoadedElementsIterator(session, collectionType, collection);
wrapper.setWrapped( wrapped );
return false;
if ( stringForm != null ) {
this.set = set;
/**
buf.append("select ");
EntityType entityType =(EntityType) type;
return null;
if ( value != old ) {
ArrayList columnJoinNumbers = new ArrayList();
private CollectionSubqueryFactory() {
String[] columns = (String[]) columnsByPropertyPath.get(propertyName);
//figure out which tables need to be fetched
Iterator itr = associations.iterator();
//NOTE: unlike all other Loaders, this one is NOT
return false;
SessionFactory sf;
None
Type keyType = getPersister( session ).getKeyType();
/**
None
CacheEntry ce = persister.buildCacheEntry( instance,state, nextVersion, getSession() );
// return collection.getOwner()
arrayHolders.put( holder.getValue(), holder );
None
// creates and renders the join fragments for inheritance
None
Integer minPoolSize = ConfigurationHelper.getInteger( Environment.C3P0_MIN_SIZE, props );
if ( fromElement.getOrigin() == null ) {
None
too long.
None
None
return StringHelper.join( "=? and ",
sequentialSelect = session.getTransactionCoordinator()
if ( useStaticLoader ) {
if ( j == 0 && identityInsert && useInsertSelectIdentity() ) { //TODO: suck into Insert
/**
byte[] b = cc.toBytecode();
Select select = new Select( getFactory().getDialect() );
None
getSession().getPersistenceContext().getCollectionsByKey().remove(
too long.
return new Alias( suffix ).toAliasStrings( getIdentifierAliases() );
if ( collectionType.hasHolder() ) {
sqlAliasSuffixes[i] = ( size == 1 ) ? "" : Integer.toString( i ) + "_";
None
return;
None
int loc = writeKey( st, id, offset, session );
}
None
None
registerFunction( "year", new StandardJDBCEscapeFunction( "year", StandardBasicTypes.INTEGER ) );
Transaction tx = suspend();
None
None
None
None
None
persister.setIdentifier( instance, generatedId, session );
None
initialize( true );
None
None
String[] idColumnNames = ( persister != null ) ?
if ( !Character.isLetter( chars[0] ) ) {
None
q.addQuerySpaces( q.getCollectionPersister( pathExpressionParser.getCollectionRole() ).getCollectionSpaces() );
//	private final SessionFactoryImplementor sessionFactory;
PersistentClass superclass = getSuperclass();
private final String role;
ukName,
too long.
Attribute typeNode = node.attribute( "type" );
metadata.getServiceRegistry()
Serializable id = persister.getIdentifierGenerator().generate( getSession(), entry );
lockMode
return "? " +
ArrayList allResultColumns = getResultColumns(propertyresult);
.getColumnIterator() );
case 23001: return null;
throw new AssertionFailure( "entity was persistent" );
None
final EntityKey entityKey = session.generateEntityKey( id, persister );
None
private static final Set COUNT_MODIFIERS = new HashSet();
}
if ( me.getValue()==element ) return me.getKey();
col += limitHandler.bindLimitParametersAtStartOfQuery( st, col );
public void initCollectionPropertyMap() {
throw new QueryException(
public String getEntityName(Criteria subcriteria, String propertyName) {
final Serializable id = session.getEntityPersister( entityName, obj ).getIdentifier( obj, session );
fk.setTable( this );
}
None
return value == null
/*if ( otherAlias!=null && !columnAlias.equals(otherAlias) ) {
return isOwnerVersioned( session ) && super.isDirty( old, current, session );
}
return getFactory().getDialect().getIdentitySelectString(
final ComponentMetamodel metamodel = new ComponentMetamodel( this );
public Getter getGetter(Class clazz) throws PropertyNotFoundException, MappingException {
throws HibernateException;
None
mergeJoins( sql.getJoinFragment() );
DisjunctionFragment df = new DisjunctionFragment();
public RowSelection getSelection() {
final CollectionPersister[] collectionPersisters = getCollectionPersisters();
if ( hasSubclasses() ) {
too long.
LOG.tracev( "Forcing inclusion of extra joins [alias={0}, containsTableAlias={1}]", alias, containsTableAlias );
// as a control measure, now update the node while it is detached and
boolean substitute = wrapCollections( session, persister, types, values);
None
oos.writeObject( loadQueryInfluencers );
String versionIncrementString = generateVersionIncrementUpdateString();
public boolean supportsIdentityColumns() {
}
}
mappings.addColumnBinding( logicalColumnName, column, table );
mappings.addColumnBinding( logicalColumnName, column, table );
None
None
if ( lhs.getImpliedJoin() != null || lhs.getFromElement().isImplied() ) {
FieldInterceptionHelper.injectFieldInterceptor( entity, getEntityName(), lazyProps, session );
String logicalOwnerTableName = ownerTable.getName();
None
inElementsFunction = true;
prepareCollectionFlushes( persistenceContext );
None
resultTypeList.add( translator.getResultType( criteria ) );
else {
//TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....
if ( getFactory().getSettings().isCommentsEnabled() ) {
int potentialTrimCharacterArgIndex = 1;
// seems to not really...
list = s.createQuery( "from Human h inner join h.friends as f with f.nickName like 'bubba'" )
try {
"midnight_seconds",
replace(
Iterator iter = collections.values().iterator();
.toString();
entityIsTransient(event, copyCache);
private final String subquery;
String entityName = action.getEntityName();
private final String[] subclassClosure;
too long.
public UnionSubclassEntityPersister(
too long.
}
}
LOG.trace( "Entity found in session cache" );
for ( EntityInsertAction action : (List<EntityInsertAction>) insertions ) {
this.disassembledState = TypeHelper.disassemble(
None
public String fromTableFragment(String name) {
java.util.Collections.sort( collectionCreations );
return isAbstract() || hasSubclasses();
private HashMap<String,Integer> latestBatches = new HashMap<String,Integer>();
buf.setLength( buf.length() - ( dialect.supportsUnionAll() ? 11 : 7 ) );
if ( resultSet.isAfterLast() ) {
return getTableName();
None
if ( sqle.getSQLState().startsWith( "23" ) ) {
private final int[] subclassPropertyTableNumberClosure;
EXPRESSION_OPENERS.add( "and" );
private final Map subclassesByDiscriminatorValue = new HashMap();
None
registerFunction( "atan2", new StandardSQLFunction("atan2", StandardBasicTypes.FLOAT) );
FromElement origin = fromElement.getOrigin();
registerFunction( "add_months", new StandardSQLFunction("add_months", StandardBasicTypes.DATE) );
None
/**
None
too long.
while ( !isResultSet && ps.getUpdateCount() != -1 ) {
/**
final AnnotationInstance sqlLoaderAnnotation = JandexHelper.getSingleAnnotation(
return load(event, persister, keyToLoad, options);
final EntityKey entityKey = session.generateEntityKey( entityId, subclassPersister );
specialCasesBefore( lcToken );
//TODO: code duplication with SingleTableEntityPersister
if ( !sessionFactory.getDialect().supportsRowValueConstructorSyntax() ) {
return Arrays.asList( naturalIdLoadAccess.load() );
subclassByDiscriminatorValue.put(
// grab its state from the ResultSet and keep it in the Session
}
object = session.instantiate( instanceClass, key.getIdentifier() );
return null;
session.getPersistenceContext().getEntry(object)
statement.registerOutParameter(col, oracletypes_cursor_value);
Object proxy = persistenceContext.getProxy(keyToLoad);
/**
return getLoadedElementsIterator(session, collectionType, collection);
@Override
// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...
value.addColumn( new Column( columnName ) );
}
}
int oracletypes_cursor_value = 0;
None
private List columnAliases = new ArrayList();
private final PathExpressionParser pathExpressionParser;
None
too long.
int count = doUpdateRows( id, collection, session );
q.addSelectScalar( getFunction( "count", q ).getReturnType( StandardBasicTypes.LONG, q.getFactory() ) );
p.getIdentifierType(),
None
public String getAddColumnString() {
Iterator iter = namedParams.entrySet().iterator();
registerFunction( "ceiling", new StandardSQLFunction( "ceiling", StandardBasicTypes.INTEGER ) );
if ( checkVersion( includeProperty ) ) {
"midnight_seconds",
object = optionalObject;
final boolean propertyIsDeferred = hasDeferred &&
public String getAuthoriser() {
parent = subcriteria.getParent();
private final int[] subclassPropertyTableNumberClosure;
rs.absolute( firstRow );
// (this lets us correctly handle proxies and multi-row or multi-column queries)
None
if ( discriminatorColumnAnnotation != null ) {
Object discriminatorValue = persister.getDiscriminatorType().nullSafeGet(
defaultLockModes = ArrayHelper.fillArray( LockMode.NONE, size );
private final Map propertyTableNumbersByNameAndSubclass = new HashMap();
throw e;
joinSpan = persistentClass.getJoinClosureSpan()+1;
if ( session.getFactory().getSettings().isWrapResultSetsEnabled() ) {
code.addIconst( 0 );
this.isKey = metamodel.isKey();
code.addCheckcast( this.targetBean.getName() );
None
code.addInvokevirtual( target_type_index, getterName, getter_desc );
too long.
if ( setters.length > 0 ) {
AST firstChild = getFirstSelectExpression();
code.addNew( BULKEXCEPTION_CLASS_NAME );
&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {
code.addOpcode(Opcode.GETFIELD);
None
// same however.
final ComponentTuplizerFactory componentTuplizerFactory = new ComponentTuplizerFactory();
code.addOpcode(Opcode.PUTFIELD);
None
Bytecode code = new Bytecode(cp, 3, 3);
Integer associationBatchNumber = entityBatchNumber.get( value );
code.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );
if ( id == null ) {
/**
if (obj == null)
registerFunction( "str", new SQLFunctionTemplate( StandardBasicTypes.STRING, "cast(?1 as char varying)" ) );
private final String[] propertyNames;
if ( Byte.TYPE.equals( javaType ) ) {
StringBuilder alter = new StringBuilder( root.toString() )
registerFunction( "%string", new VarArgsSQLFunction( StandardBasicTypes.STRING, "%string(", ",", ")" ) );
object = session.getEntityUsingInterceptor( key );
Lock newLock = new Lock( ts, uuid, nextLockId.getAndIncrement(), null );
None
BatchModeTransactionManager.getInstance().commit();
return ( SelectClause ) ASTUtil.findTypeInChildren( this, SqlTokenTypes.SELECT_CLAUSE );
bindDiscriminatorProperty( table, entity, subnode, mappings );
too long.
// HQL test
None
registerFunction( "%upper", new StandardSQLFunction( "%upper" ) );
Boolean result = entityMetamodel.getVersionProperty()
* Throws UnsupportedOperationException since this cache is read-only
return this;
too long.
return new StringBuilder( 300 )
if ( isNullableTable( j ) && isAllNull( fields, j ) ) {
try {
.append( ") REFERENCES " )
Object[] assembledProps = TypeHelper.assemble(
Iterator elems = getElementsIterator( collection, session );
final Map<String,TypedValue> namedParameters;
too long.
None
too long.
None
if ( persister.hasCollections() ) {
code.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );
private final SessionFactoryImplementor factory;
Iterator joinIter = persistentClass.getJoinClosureIterator();
too long.
Attribute packageAttribute = hibernateMappingElement.attribute( "package" );
too long.
propertyTableNumbersByNameAndSubclass.put(
too long.
protected boolean isDiscriminatorFormula() {
too long.
AbstractEntityPersister subclassPersister = (AbstractEntityPersister) persister;
private final Map alias2Return = new HashMap();
ArrayList columnNumbers = new ArrayList();
// so make certain that we do not accidentally initialize an uninitialized proxy
ArrayList formulaNumbers = new ArrayList();
columnReaders = (String[]) columnReadersByPropertyPath.get(foreignKeyProperty);
return renderSelect(
@Override
private String sqlVersionSelectString;
too long.
/**
if ( !rs.next() ) {
addTypeDependDataLoad(code, finfo.getDescriptor(), 1);
if (value.lt(1)) LOG.pooledOptimizerReportedInitialValue(value);
// Numeric Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
private final String sqlWhereString;
SessionImplementor source) {
if ( prop.getGeneration() == PropertyGeneration.INSERT ) {
None
private final String[] lazyPropertyNames;
renderScalarSelects( selectExpressions, fromClause );
private final String[] subclassColumnClosure;
public final class Subcriteria implements Criteria, Serializable {
}
None
private final FilterHelper filterHelper;
this.affectedOwner = session.getPersistenceContext().getLoadedCollectionOwnerOrNull( collection );
/**
None
handleCustomSQL( node, entity );
super.cascadeBeforeSave(source, persister, entity, copyCache);
.getColumnIterator() );
return " add column";
String[] aliasedLhsColumns = StringHelper.qualify(alias, lhsColumns);
return "";
too long.
Iterator iter = node.elementIterator();
None
identifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();
too long.
bindVersioningProperty( table, subnode, mappings, name, entity, inheritedMetas );
);
sqlWhereString = StringHelper.isNotEmpty( persistentClass.getWhere() ) ? "( " + persistentClass.getWhere() + ") " : null;
statementLogger.logStatement( query, FormatStyle.BASIC.getFormatter() );
ArrayList columns = new ArrayList();
too long.
formnos[l] = -1;
None
filterHelper = new FilterHelper( persistentClass.getFilters(), factory );
None
return null;
return getLoadedElementsIterator(session, collectionType, collection);
return initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );
too long.
// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried
resolvedJoinType = getJoinType( nullable, currentDepth );
setText( text );
return persister.createProxy( id, this );
// requiring a sub-query then generate a sub-query.
Type[] types = getPropertyTypes();
return "lower";
}
too long.
public static void bindSimpleValue(Element node, SimpleValue simpleValue, boolean isNullable,
}
throw new DetailedSemanticException( "Unable to locate appropriate constructor on class [" + className + "]", e );
* We encountered a delete request on a transient instance.
ps = session.getTransactionCoordinator()
return updateable && !ArrayHelper.isAllFalse( value.getColumnUpdateability() );
throw new MappingException(
// make it non-updateable
Iterator<PersistentCollection> wrappers = collectionEntries.keyIterator();
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Table ownerTable = collection.getOwner().getTable();
return c;
//session.getPersistenceContext().removeDatabaseSnapshot(key);
}
list.add(baz);
return lhsPersister.getPropertyColumnNames(propertyName);
try {
return lhsPersister.getSubclassPropertyTableName(propertyIndex);
try {
String associatedEntityName = propertyType.getAssociatedEntityName();
return 0;
for ( int i = 0; i < entitySpan; i++ ) {
Attribute cascadeAtt = node.attribute( "cascade" );
return dialectScopes.isEmpty() || dialectScopes.contains( dialect.getClass().getName() );
/*if ( type.isComponentType() && !propertyName.equals(rootPropertyName) ) {
None
this.comment = comment;
CollectionPersister[] collectionPersisters = getCollectionPersisters();
if ( component.getOwner().hasPojoRepresentation() ) {
None
internalInitSubclassPropertyAliasesMap( null, model.getSubclassPropertyClosureIterator() );
private final BackrefSetter setter; // this one could even be static...
bindComponent(
if ( session.isEventSource() ) {
final Loadable persister = (Loadable) getFactory().getEntityPersister( instanceEntityName );
if ( getIdentifierType().isComponentType() ) {
too long.
CompositeType componentId = ( CompositeType ) getIdentifierType();
version = persister.getVersion( instance );
subclassPropertyAliases.put( idPropertyNames[i], new String[] { idAliases[i] } );
WrapVisitor visitor = new WrapVisitor(session);
l++;
/**
code.addInvokeinterface( target_type_index, getterName, getter_desc, 1 );
registerColumnType( Types.BLOB, "BLOB" );
uniqueKeyLoaders.put(
if ( entry.getStatus() != Status.MANAGED ) {
initIdentifierPropertyPaths(mapping);
if (obj == null)
if ( useRowId ) {
default:
}
.append( persister.filterFragment( getAlias(), Collections.EMPTY_MAP ) );
fetchStyle = join ? FetchMode.JOIN : FetchMode.SELECT;
if ( componentTuplizer.hasParentProperty() ) {
update.addColumns( getPropertyColumnNames(i),
too long.
None
None
metadata.getServiceRegistry()
isNaturalKeyLookup = isLookupByNaturalKey;
.getColumnIterator() );
property = identifierProperty;
Iterator iter = node.elementIterator();
String entityName = ( (OneToMany) collection.getElement() ).getReferencedEntityName();
None
if ( mappings.getClass( extendsName ) == null && mappings.getClass( getClassName( extendsName, mappings ) ) == null ) {
}
final Properties properties = new Properties();
final Object nextVersion = getNextVersion(event);
settings.setRegionFactory( createRegionFactory( properties, ( useSecondLevelCache || useQueryCache ), serviceRegistry ) );
private final String[] subclassPropertyNameClosure;
too long.
/**
boolean[] includeInWhere = entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.ALL
return true;
Element discriminatorResult = returnElement.element("return-discriminator");
if ( StringHelper.isNotEmpty( s ) ) {
boolean hasOrphanDelete = loadedPersister != null && loadedPersister.hasOrphanDelete();
includeInSelect[i] = !element.isFetch();
None
hydratedObjects.add( object );
private Interceptor interceptor;
None
{
too long.
if ( session.getFactory().getSettings().isIdentifierRollbackEnabled() ) {
resultRow = new Object[ columnProcessors.length ];
* Iterate the entity mappings
if ( lockMode==LockMode.PESSIMISTIC_FORCE_INCREMENT) {
boolean ownerChanged = loadedPersister != currentPersister ||				// if either its role changed,
None
protected abstract BytecodeProvider buildBytecodeProvider();
property = identifierProperty;
for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
private void writeObject(ObjectOutputStream oos) throws IOException {
if ( j == 0 ) {
return collectionType.getElementsIterator(collection, session);
!currentPersister
None
}
super.setDataType(propertyType);
None
private Map<Object,Object> copyToEntityMap = new IdentityHashMap<Object,Object>( 10 );
String[] keyColumnNames = persister.getKeyColumnNames();
return result;
expectedType = getType() == HqlSqlTokenTypes.PLUS ? StandardBasicTypes.DOUBLE : rhType;
return null;
for ( int i = 0; i < position - size; i++ ) {
}
/**
public static class BasicExpectation implements Expectation {
update.addColumns( getPropertyColumnNames(i),
CompositeType componentType = ( CompositeType ) types[i];
if ( j == 0 && identityInsert ) {
errorIfDML();
None
if ( getFactory().getSettings().isCommentsEnabled() ) {
if ( LOG.isTraceEnabled() ) {
// TODO: is this still needed?
None
transactionCoordinator().getTransactionContext().managedFlush();
FromClause from = getCurrentFromClause();
return NOT_NULL_COLLECTION;
// the entity is not associated with the session, so
if ( tableUpdateNeeded[j] ) {
final PreparedStatement insert;
return "";
dehydrate( id, fields, null, notNull, propertyColumnInsertable, j, insert, session, index, false );
// Dialect method overrides ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
None
&& ForeignKeys.isTransient( childEntityName, child, null, session ) ) {
isRowToUpdate = false;
None
Attribute chNode = node.attribute( "check" );
too long.
isRowToUpdate = true;
if ( useBatch && updateBatchKey == null ) {
registerFunction( "ascii", new StandardSQLFunction( "ascii", StandardBasicTypes.INTEGER ) );
final PreparedStatement update;
snapshot[ lazyPropertyNumbers[j] ] = lazyPropertyTypes[j].deepCopy( propValue, factory );
too long.
List collectionOwners = new ArrayList();
if ( useVersion && entityMetamodel.getOptimisticLockStyle() == OptimisticLockStyle.VERSION ) {
Object unmergedInstance = mergeMap.get( entityEntryInstance );
final PreparedStatement insert;
Type elementType = persister.getElementType();
getIdentifierType().nullSafeSet( delete, id, index, session );
columnAliases = ( String[] ) fieldResults.get(propertyName);
if ( useVersion ) {
entry = persistenceContext.getCollectionEntryOrNull( collection );
public Object[] toArray() {
final LockOptions lockOptions = parameters.getLockOptions();
final boolean[] tableUpdateNeeded = getTableUpdateNeeded( dirtyFields, hasDirtyCollection );
Object[] propertyValues = action.getState();
private List embeddedParameters;
private final String[] propertyNames;
Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() ) ;
/** The column parameter */
fromElement.setText( queryableCollection.getTableName() + " " + getTableAlias() );
* Call setEntity() on a cacheable query - see FORGE-265
None
public Object merge(String entityName, Object object) throws HibernateException {
None
String[] columnNames,
updateStrings = new String[span];
settings.getDefaultCatalogName(),
updateStrings = getUpdateStrings(
return IdentifierGeneratorHelper.SHORT_CIRCUIT_INDICATOR;
if ( methodName.startsWith( "is" ) ) {
.toString();
None
trimSource = ( String ) args.get( 0 );
boolean[] notNull = getPropertiesToInsert( fields );
if ( object == self ) {
private final String[] userAliases;
id = insert( fields, getPropertyInsertability(), getSQLIdentityInsertString(), object, session );
whereString.append('('); //TODO: unnecessary for databases with ANSI-style joins
found = true;
private final static String C3P0_STYLE_MIN_POOL_SIZE = "c3p0.minPoolSize";
// Also need to check that the expected identifier type matches
private transient boolean ignore;
private final SessionFactoryImplementor factory;
ignore = false;
HolderInstantiator holderInstantiator = buildHolderInstantiator( resultTransformer );
snapshot = persister.isMutable() ?
}
registerColumnType( Types.VARBINARY, "blob($l)" );
ignore = false;
Integer initialPoolSize = ConfigurationHelper.getInteger( C3P0_STYLE_INITIAL_POOL_SIZE, props );
deleteStrings = generateSQLDeletStrings( loadedState );
deleteStrings = getSQLDeleteStrings();
}
if ( !(other instanceof Enrolment) ) return false;
final String comment,
createJoin( alias, innerJoin, includeSubclasses ).toFromFragmentString();
too long.
String propertyPath = getText() + "." + getNextSibling().getText();
final JoinFragment join = getFactory().getDialect().createOuterJoinFragment();
too long.
final boolean joinIsIncluded = isClassOrSuperclassTable( j ) ||
if ( hasIdentifierProperty() ) {
final int j = tableNumbers[i];
@Override
//render the where and from parts
}
driver = (Driver) Class.forName( driverClassName ).newInstance();
